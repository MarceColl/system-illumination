<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    
    <title>Debugging Rustler on Illumos - SYSTEM&bull;ILLUMINATION</title>
    <link rel="stylesheet" href="/style.css" />
    <link rel="icon" type="image/png" href="/favicon.png" />
  </head>
  <body>
    <header class="header">
      <div class="header-container">
	<div class="logo">
	  <a href="/">
	    <span class="sun">SYSTEM</span>&bull;ILLUMINATION
	  </a>
	</div>
      </div>
    </header>

    <div class="container">
      <main class="article">
	<h1 class="title">Illumination #001: Debugging Rustler on Illumos</h1>
	<div class="content">
	  <p>
	    Welcome to <span class="sun">SYSTEM</span>&bull;ILLUMINATION! This is the first
	    illumination I have written and the one that prompted me to start this space.
	    This first session tackles several topics as you join me on the journey
	    I took to debug <a href="">Rustler</a> misbehaving on OmniOS.
	  </p>

	  <disclaimer>
	    I'm a beginner with Illumos. This page serves a twofold purpose: to help me
	    document and clarify my learnings as I delve into the Illumos/Solaris world.
	    And to shine a bit of light into a system that is fairly obscure and hard
	    to get good info on. However, because I'm also learning it, I may be wrong
	    on many things. Use the information in these pages as a starting point for
	    your own investigations.
	  </disclaimer>

	  <h2>From Linux to Illumos</h2>

	  <p>
	    Recently I decided I wanted to delve deeper into the
	    Illumos ecosystem; I had briefly used it a couple of years ago
	    for a small server I was running. Two weeks ago, I had
	    to decide on and build the final infrastructure
	    for <a href="https://katarineko.com">Katarineko</a> a
	    personal project I'm about to release. I had the choice
	    between using my trusted Linux or giving in to the voice in my
	    head that said <em>USE ILLUMOS!</em>. I did give in, maybe
	    not the sanest choice, but it is my choice.
	  </p>

	  <p>
	    Katarineko is built
	    with <a href="https://elixir-lang.org/">Elixir</a>, a
	    language that runs on the Erlang virtual machine. For 
	    reasons I will not get into here, I also have a couple of
	    NIFs written in Rust. NIFs are the main way you can call
	    into compiled languages from Erlang/Elixir. The
	    <a href="https://github.com/rusterlium/rustler">Rustler</a>
	    project is a very straightforward way of integrating NIFs
	    written in Rust, it handles compilation lifecycle,
	    exposing all the right structures and functions, and
	    serialization between Erlang and Rust, including support
	    for Serde.  We'll get into how this works a bit further
	    down.
	  </p>

	  <p>
	    Migrating was quite simple. I
	    used <a href="https://pkgsrc.illumos.am/">pkgsrc</a> to
	    get Elixir packages, set up some zones, and I was up and
	    running within a day. At first, everything appeared to be
	    running properly: there were no errors, and the page was
	    running smoothly. I shared the beta version with a friend
	    that was testing and he tried to use the Spaced-Repetition system.
	    <icode>:erlang.nif_error(:nif_not_loaded)</icode>. The Sun
	    gods had provided an opportunity to explore the famous
	    observability tooling of Solaris earlier than I
	    thought. Let's get right to it!
	  </p>

	  <h2><span class="sun">dtrace</span> primer</h2>

	  <p>
	    One reason for moving to Illumos was to
	    learn <a href="/man/dtrace.8.html"><man-ref>dtrace(8)</man-ref></a>.
	    <strong><em>dtrace</em></strong> is a dynamic tracing
	    framework to observe the state and evolution of the system
	    and user programs. We will use it extensively during this
	    debugging session, so it is better to become acquainted
	    with its syntax and capabilities. The D language is a mix
	    between
	    <a href="https://en.wikipedia.org/wiki/AWK">awk</a> and
	    C. Let's check an example:
	  </p>

	  <code>

    #!/usr/sbin/dtrace -s

    <keyword>syscall::open:entry</keyword>,
    <keyword>syscall::openat:entry</keyword><number-ref>1</number-ref>
    <filter>/pid == $target/</filter><number-ref>2</number-ref>
    {
	printf(<string>"target used open syscall on %s\n"</string>, copyinstr(arg0)); <number-ref>3</number-ref>
    }
	  </code>

	  <p>
	    Each D program consists of a set of clauses. Each clause has 3 sections:
	    <ul>
	      <li>
		<em>Probes</em> that enable the clause
	      </li>
	      <li>
		<em>Predicates</em> are expressions enclosed in slashes that are evaluated
		at probe firing time. If the expression evaluates to true, the actions will
		execute. <em>Predicates</em> are optional and can be omitted.
	      </li>
	      <li>
		<em>Actions</em> are a list of C-like statements that will be executed
		if the probe fires and the predicate evaluates to true.
	      </li>
	    </ul>
	  </p>

	  <p>
	    Another useful feature we'll use soon is <em>thread-local variables</em>, this allows
	    you to conditionally run some actions only after a previous condition has been met.
	    You'll see how this becomes useful very soon. Thread-local variables are referenced
	    by using the <em>-></em> operator to the identifier <em>self</em>.
	    For example <icode>self->trace = 1</icode> sets a thread-local variable
	    named <em>trace</em> to the value one.
	  </p>

	  <p>
	    You can read more about <strong><em>DTrace</em></strong> in the
	    <a href="https://illumos.org/books/dtrace/">Dynamic Tracing Guide</a>
	  </p>

	  <h2>Erlang NIFs with Rustler</h2>

	  <p>
	    NIFs didn't load. How do NIFs usually load?
	    The only thing I knew is that NIFs are loaded
	    from a shared library, an <icode>.so</icode> file in
	    Unix-like systems. So let's use <strong><em>DTrace</em></strong>
	    to figure out what Erlang code is responsible for this to try
	    to find where it goes wrong.  Since it is a shared library
	    object, it is probably using dlopen.  For reasons I cannot
	    remember, I traced the <a href="/man/open.2.html"><man-ref>open(2)</man-ref></a>
	    syscall instead. Here's a very small script I wrote for this purpose.
	  </p>

	  <code>
 <string>erlang_nif.d</string>

    <keyword>syscall::open:entry</keyword>
    /<filter>pid == $target && strstr(copyinstr(arg0), "libkatarineko_srs") != NULL</filter>/
    {
	printf(<string>"OPENED LIBKATARINEKO %s\n"</string>, copyinstr(arg0));
	ustack();
    }

    <string>You can run it like so:</string>
    <filter>#</filter> <keyword>dtrace</keyword> -s erlang_nif.d -c 'mix test'
	  </code>

	  <p>
	    This D script contains only one clause, which will execute the actions whenever
	    the target process (specified by <icode>-p</icode> or
	    <icode>-c</icode>) executes the <em>open</em> syscall with a first argument
	    that contains the string <icode>"libkatarineko_srs"</icode>. If that matches
	    we'll print what the argument was and print the user-space stack
	    (with <icode>ustack()</icode>). Running it gives us the following stack trace:
	  </p>

	  <code>
    dtrace: script 'erlang_nif.d' matched 8 probes
    CPU     ID                    FUNCTION:NAME
    28    618                       open:entry OPENED LIBKATARINEKO /root/katarineko/_build/prod/lib/katarineko/priv/native/libkatarineko_srs.so
		ld.so.1`_syscall6+0x1b
		ld.so.1`<filter>open</filter>+0x33
		ld.so.1`file_open+0x456
		ld.so.1`find_path+0x96
		ld.so.1`load_so+0x240
		ld.so.1`load_path+0x87
		ld.so.1`load_one+0x15c
		ld.so.1`dlmopen_core+0x11e
		ld.so.1`dlmopen_intn+0x93
		ld.so.1`dlmopen_check+0x71
		ld.so.1`dlopen+0x59
		beam.smp`erts_sys_ddll_open_noext+0x2f
		beam.smp`erts_sys_ddll_open+0x73
		beam.smp`<keyword>erts_load_nif</keyword>+0x5b1
		beam.smp`_Z17beam_jit_load_nifP7processPKvPm+0x3a
		0xfffffbffe20012b0
		0x3b
	  </code>

	  <p>
	    We quickly find <a href="https://github.com/erlang/otp/blob/ed8445a63861f510d21e27c9122e4fafa8039d9d/erts/emulator/beam/erl_nif.c#L4679">which function</a>
	    in Erlang is responsible for loading the nifs.

	    Let's take a look at the function and see what could be going wrong or what else we could inspect to understand the problem better.
	    The function seems to take care of most error conditions that were going on through my mind.
	    It seemed there was no problem loading the shared library.
	    In case I was wrong, I added a user function trace for <icode>load_nif_error</icode>, but it was never called.
	  </p>

	  <code>
    <keyword>pid$target::load_nif_error:entry</keyword>
    {
	    printf(<string>"ERROR: %s\n"</string>, copyinstr(arg0));
    }
	  </code>

	  <p>
	    To confirm that it was working properly, I traced the user function <icode>patch_call_nif_early</icode> that is called only in the case
	    everything goes well.
	  </p>

	  <code>
    if (ret == am_ok) {
	<string>...</string>
	patch_call_nif_early(entry, this_mi);
	<string>...</string>
    }
	  </code>

	  <p>
	    It was called, so Erlang appeared to load everything correctly and to consider the operation successful; however, no
	    NIF was actually being loaded.

	    I needed to understand a bit more how the shared library actually exposes the NIFs and how Erlang discovers the functions.
	    Here I also cloned the Rustler repo and checked if the tests failed for their repo as well or if it was my own setup.
	    All of their tests failed as well.
	  </p>

	  <h2>NIF Shared Libraries</h2>

	  <p>
	    The <icode>entry</icode> above is of type
	    <icode>ErlNifEntry</icode>.
	  </p>

	  <code>
    <filter>typedef struct</filter> enif_entry_t
    {
	<keyword>int</keyword> major;
	<keyword>int</keyword> minor;
	<keyword>const char*</keyword> name;
	<keyword>int</keyword> num_of_funcs;
	<keyword>ErlNifFunc*</keyword> funcs;
	<keyword>int</keyword>  (*load)   (ErlNifEnv*, void** priv_data, ERL_NIF_TERM load_info);
	<keyword>int</keyword>  (*reload) (ErlNifEnv*, void** priv_data, ERL_NIF_TERM load_info);
	<keyword>int</keyword>  (*upgrade)(ErlNifEnv*, void** priv_data, void** old_priv_data, ERL_NIF_TERM load_info);
	<keyword>void</keyword> (*unload) (ErlNifEnv*, void* priv_data);

	/* Added in 2.1 */
	<keyword>const char*</keyword> vm_variant;

	/* Added in 2.7 */
	<keyword>unsigned</keyword> options;   /* Unused. Can be set to 0 or 1 (dirty sched config) */

	/* Added in 2.12 */
	<keyword>size_t</keyword> sizeof_ErlNifResourceTypeInit;

	/* Added in 2.14 */
	<keyword>const char*</keyword> min_erts;
    } <keyword>ErlNifEntry</keyword>;
	  </code>

	  <p>
	    When Erlang loads a NIF shared library, it looks for a symbol <icode>nif_init</icode> and calls it with no arguments.
	    This function returns an <icode>ErlNifEntry</icode> that, among other information, contains a field useful for us: <icode>num_of_funcs</icode>.
	    I was thinking that maybe, for some reason, under Illumos Rustler was not properly populating the function array.
	  </p>

	  <p>
	    Now, I wasn't sure how to use structs in DTrace, and I was in an <a href="https://en.wikipedia.org/wiki/AVE">AVE</a> heading to my first
	    <a href="https://en.wikipedia.org/wiki/Go_(game)">Go</a> tournament and I had very bad internet so I went with what I knew.

	    I created a small shared library that internally called the actual NIF shared library.
	    The idea was to be able to introspect what the NIF shared library was returning in the <icode>ErlNifEntry</icode>.
	  </p>

	  <code>
    <filter>#include</filter> <<string>dlfcn.h</string>>
    <filter>#include</filter> <<string>stdio.h</string>>
    <filter>#include</filter> <<string>stdlib.h</string>>

    <filter>typedef struct</filter> enif_entry_t
    {
	<keyword>int</keyword> major;
	<keyword>int</keyword> minor;
	<keyword>const char *</keyword>name;
	<keyword>int</keyword> num_of_funcs;
        <string>// We don't need any more of the struct for now</string>
    } <keyword>nif_entry</keyword>;

    <keyword>void*</keyword> _init_nif() {
	<keyword>const char *</keyword>lib_path = <string>"./priv/native/rustler_serde_test.so"</string>;

	<keyword>void *</keyword>hdl = dlopen(lib_path, RTLD_NOW);
	<keyword>void *</keyword>sym = dlsym(hdl, <string>"nif_init"</string>);
	<keyword>nif_entry*</keyword> (*initfn)(void) = (nif_entry* (*)(void))sym;
	<keyword>nif_entry *</keyword>entry = initfn();
	printf(
	    <string>"NIF loaded: %s (version %d.%d)\n"</string>,
	    entry->name,
	    entry->major,
	    entry->minor
	);
	printf(<string>"# Funcs: %d\n"</string>, entry->num_of_funcs);

	return (<keyword>void*</keyword>)entry;
    }

    <keyword>void*</keyword> init_nif() {
	    return _init_nif();
    }
	  </code>

	  <p>
	    I compiled this as a shared library and loaded this library instead of the original.
	    It all loaded fine, the name and version looked good (so it seems we did have a valid entry).
	    However the number of functions was zero.
	    It seems that whatever Rustler does to gather all the NIFs wasn't working on Illumos.
	  </p>

	  <h2>Rustler Internals</h2>

	  <p>
	    I dove into the <a href="https://github.com/rusterlium/rustler/blob/master/">Rustler codebase</a>.
	    It is fairly small but it contains a lot of fairly hard to follow code (at least for me) with several macros and string-based code generation.
	    Since I knew that at some point it had to generate a NIF entry I looked for places where entry was referenced.
	    Finally I found <a href="https://github.com/rusterlium/rustler/blob/730303e4aca8c526f25ec3b73118974696be3394/rustler_codegen/src/init.rs#L88-L91">this section</a> of the code.
	  </p>

	  <code>
    let nif_funcs: <keyword>Box</keyword><[_]> =
	rustler::codegen_runtime::inventory::iter::<rustler::Nif>()
	.map(<keyword>rustler</keyword>::<keyword>Nif</keyword>::get_def)
	.collect();
	  </code>

	  <p>
	    By some (for now unkown) mechanism the functions were available in this <em>inventory</em> iterator.
	    A quick <icode>println!</icode> debugging showed that indeed, <icode>nif_funcs</icode> was empty.
	    I also saw that the NIFs were <a href="https://github.com/rusterlium/rustler/blob/730303e4aca8c526f25ec3b73118974696be3394/rustler_codegen/src/nif.rs#L57-L97">added to this inventory</a>
	    in the <icode>#[nif]</icode> macro.
	  </p>

	  <code>
    quote! {
        rustler::codegen_runtime::inventory::submit!(
            <keyword>rustler</keyword>::<keyword>Nif</keyword> {
               <string>...</string>
	    }
	}
    }
	  </code>

	  <p>
	    Somehow, at the top level, <icode>submit!</icode> was adding structs to this <icode>inventory</icode>.
	    And this mechanism intuitively seemed to be the culprit.
	    I validated that these macros were being called for the functions I was exposing, but when collecting the NIFs, they were empty.
	    One more layer, enter the <a href="https://github.com/dtolnay/inventory">Inventory crate</a>.
	  </p>

	  <h2>The Inventory Crate</h2>

	  <p>
	    <strong><em>Inventory</em></strong> defines itself as
	  </p>

	  <quote>
	    a way to set up a plugin registry into which plugins can be registered from any source file linked into your application.
	    There does not need to be a central list of all the plugins
	  </quote>

	  <p>
	    It also explains a bit the mechanism as to how it works
	  </p>

	  <quote>
	    Inventory is built on runtime initialization functions similar to __attribute__((constructor)) in C, and similar to the ctor crate.
	    Each call to inventory::submit! produces a shim that evaluates the given expression and registers it into a registry of its corresponding type.
	    This registration happens dynamically as part of life-before-main for statically linked elements.
	    Elements brought in by a dynamically loaded library are registered at the time that dlopen occurs.
	  </quote>

	  <p>
	    <strong><em>Inventory</em></strong> is a very small library, a little under 600 lines of code, most of it comments and documentation.
	    The most interesting and relevant part is the <a href="https://github.com/dtolnay/inventory/blob/master/src/lib.rs#L498-L570"> <icode>__do_submit</icode> macro </a>.
	    Let's dissect what the macro is doing.
	  </p>

	  <p>
	    It requires you to define a <em>Plugin</em> type.
	    In this case it is <icode>rustler::Nif</icode>.
	    Once the library is loaded, when you call the <icode>collect!</icode> macro from the crate it will implement a <icode>Registry</icode> trait for your type.
	    This trait will later allow submitting the structs at runtime and building the linked list dynamically.
	    Let's see how that works.
	  </p>

	  <p>
	    For each <icode>submit!</icode> it generates an <icode>__INVENTORY</icode> value that contains the <icode>rustler::Nif</icode> struct.
	  </p>

	  <code>
    static __INVENTORY: $crate::Node = $crate::Node {
	value: &{ $($value)* },
	next: $crate::core::cell::UnsafeCell::new($crate::core::option::Option::None),
	#[cfg(target_family = "wasm")]
	initialized: $crate::core::sync::atomic::AtomicBool::new(false),
    };
	  </code>

	  <p>
	    A function <icode>__ctor()</icode> is generated; when called at library load time, it submits the node to the registry.
	  </p>

	  <code>
    unsafe extern "C" fn __ctor() {
	unsafe { $crate::ErasedNode::submit(__INVENTORY.value, &__INVENTORY) }
    }
	  </code>

	  <p>
	    Calling all of these functions populates a linked list (using the <icode>next</icode> attribute from the <icode>Node</icode> type)
	    that will then be walked by the <icode>iter()</icode> method we saw earlier.

	    The last piece of the puzzle adds the address of <icode>__ctor()</icode> to the <icode>.init_array</icode> section of the ELF file in the case of Illumos.
	  </p>

	  <code>
    $($used)+
    #[cfg_attr(
	all(
	    not(target_family = "wasm"),
	    any(
		target_os = "linux",
		target_os = "android",
		target_os = "dragonfly",
		target_os = "freebsd",
		target_os = "haiku",
		target_os = "illumos",
		target_os = "netbsd",
		target_os = "openbsd",
		target_os = "none",
	    )
	),
	link_section = ".init_array",
    )]
    #[cfg_attr(
	target_family = "wasm",
	$crate::__private::attr(
	    any(all(stable, since(1.85)), since(2024-12-18)),
	    link_section = ".init_array",
	),
    )]
    #[cfg_attr(
	any(target_os = "macos", target_os = "ios"),
	link_section = "__DATA,__mod_init_func,mod_init_funcs",
    )]
    #[cfg_attr(windows, link_section = ".CRT$XCU")]
    static __CTOR: unsafe extern "C" fn() = __ctor;
	  </code>

	  <h2><icode>ld.so.1</icode></h2>

	  <p>
	    <a href="/man/ld.so.1.1.html"><man-ref>ld.so.1(1)</man-ref></a> is the Illumos runtime linker for dynamic objects, and it is responsible 
	    for loading the shared library objects like our NIF library.

	    One of the tasks after loading and resolving symbols is calling the initialization functions, there are several sections for this, but as mentioned
	    before the one we care about is <icode>.init_array</icode>.

	    <icode>.init_array</icode> is an array of pointers to functions that is run sequentially.
	    These functions are executed before <a href="/man/dlopen.3c.html"><man-ref>dlopen(3C)</man-ref></a> returns.
	    Let's check if those were properly populated in the binary.
	  </p>

	  <code>
    $ elfdump priv/native/rustler_serde_test.so | grep CTOR
	[1726]  0x00000000001e87f0 0x0000000000000008  OBJT LOCL  D    0 .init_array    _ZN18rustler_serde_test4test1_6__CTOR17hff0bbe6e5632e929E
	[1815]  0x00000000001e87f8 0x0000000000000008  OBJT LOCL  D    0 .init_array    _ZN18rustler_serde_test1_6__CTOR17hb75d58ed18ea6865E
	[1816]  0x00000000001e8800 0x0000000000000008  OBJT LOCL  D    0 .init_array    _ZN18rustler_serde_test1_6__CTOR17hc62992ae880cf163E
	[1817]  0x00000000001e8808 0x0000000000000008  OBJT LOCL  D    0 .init_array    _ZN18rustler_serde_test1_6__CTOR17hd4e36f059b2ed20eE
	[1914]  0x00000000001e8810 0x0000000000000008  OBJT LOCL  D    0 .init_array    _ZN18rustler_serde_test4json1_6__CTOR17hc50c07f6139fceefE
	[1915]  0x00000000001e8818 0x0000000000000008  OBJT LOCL  D    0 .init_array    _ZN18rustler_serde_test4json1_6__CTOR17h600856d690bcf7dcE
	[1916]  0x00000000001e8820 0x0000000000000008  OBJT LOCL  D    0 .init_array    _ZN18rustler_serde_test4json1_6__CTOR17h47804ad1bc4e3b93E
	[1917]  0x00000000001e8828 0x0000000000000008  OBJT LOCL  D    0 .init_array    _ZN18rustler_serde_test4json1_6__CTOR17hd7df8ce4201058e0E
	[1918]  0x00000000001e8830 0x0000000000000008  OBJT LOCL  D    0 .init_array    _ZN18rustler_serde_test4json1_6__CTOR17h558cc91143bf9f1bE
	[1919]  0x00000000001e8838 0x0000000000000008  OBJT LOCL  D    0 .init_array    _ZN18rustler_serde_test4json1_6__CTOR17h63d284544c9c3173E
	  </code>

	  <p>
	    So they are where they are supposed to be; what's unclear is whether they are properly called.
	    Since it is not working maybe the Illumos runtime linker doesn't take into account <icode>.init_array</icode>?
	    The other option is that the functions themselves are not working but I find that unlikely and I don't think there should be a
	    difference between Linux and Ilumos in this case.

	    Let's test the theory and check if they are being called at all.
	    Since the symbols will not be available until dlopen has been called we'll need to employ a bit of a trick with dtrace.
	  </p>

	  <p>
	    We'll start with a script that stops the process when we are about to start the <a href="/man/dlopen.3.html"><man-ref>dlopen(3)</man-ref></a>
	    initialization section, let's browse the linker code to find a good place to trace.

	    Once we find it, the idea is to determine when we open the library we care about, and then stop before initialization
	    (but after symbols are loaded; very important, since we need to be able to attach probes to the <icode>__CTOR</icode> symbols).

	    The <a href="https://github.com/illumos/illumos-gate/blob/master/usr/src/cmd/sgs/rtld/common/util.c#L702">
	      <icode>call_init</icode> function</a> seems like a good place to do so.

	    Let's write the D script to stop the process once we arrive there.
	  </p>

	  <code>
    <keyword>pid$target::dlopen:entry</keyword>
    /<filter>strstr(copyinstr(arg0), <string>"rustler_serde_test.so"</string>) != NULL</filter>/
    {
	printf(<string>"DLOPEN: %s\n"</string>, copyinstr(arg0));
	self->trace = 1;
    }

    <keyword>pid$target::dlopen:return</keyword>
    /<filter>self->trace == 1</filter>/
    {
	printf(<string>"DLOPEN RETURN"</string>);
	self->trace = 0;
    }

    <keyword>pid$target::call_init:entry</keyword>
    /<filter>self->trace == 1</filter>/
    {
	printf(<string>"PREINIT: %s %d"</string>, copyinstr(arg0), pid);
	stop();
    }
	  </code>

	  <p>
	    This script has three clauses, the first one checks when we are executing <a href="/man/dlopen.3.html"><man-ref>dlopen(3)</man-ref></a>
	    for the target library we want.

	    In that case we set a thread-local variable stating that we are intending to trace, the second clause removes that thread-local
	    variable so no other calls to <icode>call_init</icode> stop the process.

	    The third clause ensures we stop the process just before starting the initialization code.
	    We need to call this script with <strong><em>DTrace</em></strong>'s <icode>-w</icode> flag,
	    to allow destructive operations (like stopping the process).
	  </p>

	  <p>
	    Once we have the process stopped right were we want to, we can do a user-function tracing like
	    we did before for one of the <icode>__CTOR</icode> symbols.
	  </p>

	  <code>
	    <keyword>pid$target::_ZN18rustler_serde_test1_6__CTOR17hc62992ae880cf163E:entry</keyword>
	  </code>

	  <p>
	    Now we kill the first dtrace program since we can only trace a program once and run the second D script.
	    That will automatically resume the process and output trace logs if any of the probes matched.
	    <strong><em>They did not. Does <a href="/man/ld.so.1.1.html"><man-ref>ld.so.1(1)</man-ref></a> support <icode>.init_array</icode>?</em></strong>.
	  </p>

	  <h2>Et tu, ELF?</h2>

	  <p>
	    It does support it. I examined the code and, from the same <icode>call_init</icode> function we traced, we can see that it 
	    calls the functions in <icode>.init_array</icode>
	  </p>

	  <code>
    <keyword>void</keyword> call_init(<keyword>Rt_map **</keyword>tobj, <keyword>int</keyword> flag) {
        <string>...</string>
	call_array(INITARRAY(lmp), INITARRAYSZ(lmp), lmp, SHT_INIT_ARRAY);
        <string>...</string>
    }
	  </code>

	  <p>
	    You can also check the <a href="https://github.com/illumos/illumos-gate/blob/master/usr/src/cmd/sgs/rtld/common/util.c#L659">
	      code for <icode>call_array</icode> </a>.

	    It is very straightforward, iterate over the array and call each function in turn.
	    <em>So, why aren't they being called?</em>.
	    Let's try to get some more information from the <icode>call_init</icode> function.
	    This function takes as its first parameter, an <icode>Rt_map</icode>.
	    Let's see what that looks like and if we can get any extra information from there.
	    For example the size of the array.
	    We'll write a D script that introspects into this struct.
	  </p>

	  <code>
    struct rt_map {
	<string>...</string>
	Addr		*rt_initarray;	/* .init_array table */
	Addr		*rt_finiarray;	/* .fini_array table */
	Addr		*rt_preinitarray; /* .preinit_array table */
	<string>...</string>
	uint_t		rt_initarraysz;	/* size of .init_array table */
	uint_t		rt_finiarraysz;	/* size of .fini_array table */
	uint_t		rt_preinitarraysz; /* size of .preinit_array table */
	<string>...</string>
    };
	  </code>

	  <p>
	    I have zoomed in on the relevant fields, you can check the whole struct <a href="https://github.com/illumos/illumos-gate/blob/master/usr/src/cmd/sgs/include/rtld.h#L663-L733">here</a>.
	    Let's modify the <icode>stop()</icode> script to print the <icode>rt_initarraysz</icode> that is passed to <icode>call_array</icode>.
	  </p>

	  <code>
    <keyword>pid$target::dlopen:entry</keyword>
    /<filter>strstr(copyinstr(arg0), <string>"rustler_serde_test.so"</string>) != NULL</filter>/
    {
	printf(<string>"DLOPEN: %s\n"</string>, copyinstr(arg0));
	self->trace = 1;
    }

    <keyword>pid$target::dlopen:return</keyword>
    /<filter>self->trace == 1</filter>/
    {
	printf(<string>"DLOPEN RETURN"</string>);
	self->trace = 0;
    }

<diffred>-   <keyword>pid$target::call_init:entry</keyword>
-   /<filter>self->trace == 1</filter>/
-   {
-	printf(<string>"PREINIT: %s %d"</string>, copyinstr(arg0), pid);
-	stop();
-   }</diffred>

<diffgreen>+   <keyword>pid$target::call_array:entry</keyword>
+   /<filter>self->trace == 1</filter>/
+   {
+	printf(<string>"CALL ARRAY (size: %d)"</string>, arg1);
+   }</diffgreen>
	  </code>

	  <p>
	    When I ran this I got: <icode>CALL ARRAY (size: 8)</icode>, now taking into
	    account that this is in bytes, this means the array <em>only has one element!</em>
	  </p>

	  <p>
	    Let's check what <a href="/man/elfedit.1.html"><man-ref>elfedit(1)</man-ref></a>
	    has to say about the <icode>.init_array</icode> section
	    and why it reports a size of 1 when I see
	    10 <icode>__CTOR</icode> symbols inside.
	  </p>

	  <code>
    <filter>$</filter> elfedit -e 'shdr:dump .init_array' ./priv/native/rustler_serde_test.so

    Section Header[693]:  sh_name: .init_array
	sh_addr:      0x1e87e8            sh_flags:   [ SHF_WRITE SHF_ALLOC ]
	sh_size:      0x8                 sh_type:    [ SHT_INIT_ARRAY ]
	sh_offset:    0x1d87e8            sh_entsize: 0x8 (1 entry)
	sh_link:      0                   sh_info:    0
	sh_addralign: 0x8

    Section Header[694]:  sh_name: .init_array
	sh_addr:      0x1e87f0            sh_flags:   [ SHF_WRITE SHF_ALLOC 0x100000 ]
	sh_size:      0x50                sh_type:    [ SHT_INIT_ARRAY ]
	sh_offset:    0x1d87f0            sh_entsize: 0x8 (10 entries)
	sh_link:      0                   sh_info:    0
	sh_addralign: 0x8
	  </code>

	  <p>
	    <em>Ooh..</em> we get <strong>TWO</strong> <icode>.init_array</icode> sections!!
	    And the first one has one entry (<icode>0x8 bytes</icode>).
	    Looking at the <a href="/man/ld.so.1.1.html"><man-ref>ld.so.1(1)</man-ref></a> <icode>call_init</icode> code again I can see that it only
	    expects a single <icode>.init_array</icode> section, and I guess it takes the first one it sees? (The answer is no, but I didn't know yet).
	  </p>

	  <h2>Et tu, <icode>/usr/bin/ld</icode>?</h2>

	  <p>
	    Okay, so how do I fix this? Several things came to mind, first thing was to create a link script, however it seems
	    that the Illumos linker is a bit more limited in this aspect than the GNU one I'm (more or less) used to.

	    There is a thing called a <icode>mapfile</icode> but the documentation is honestly pretty bad and I couldn't figure it out.
	  </p>

	  <p>
	    The next thing I tested was creating a C program using <a href="/man/libelf.3lib.html"><man-ref>libelf(3lib)</man-ref></a> to try to merge both sections.
	    However, when I did, <a href="/man/elfdump.1.html"><man-ref>elfdump(1)</man-ref></a> reported many errors about broken references.
	    In between those complaints I saw one thing that caught my eye.
	  </p>

	  <code>
    <keyword>DT_INIT_ARRAY</keyword> does not point to a section of type SHT_INIT_ARRAY.
    <keyword>DT_INIT_ARRAYSZ</keyword> is invalid
	  </code>

	  <p>
	    Hmmm, what is this?
	    These are <icode>.dynamic</icode> table entries, and they tell the runtime linker where to obtain certain information.
	    And these two entries in particular tell <a href="/man/ld.so.1.1.html"><man-ref>ld.so.1(1)</man-ref></a> which <icode>.init_array</icode> section to use!
	    <a href="/man/elfdump.1.html"><man-ref>elfdump(1)</man-ref></a> has the <icode>-d</icode> flag to dump the dynamic section. 
	  </p>

	  <code>
    <filter>$</filter> <keyword>elfdump</keyword> -d priv/native/rustler_serde_test.so

    Dynamic Section:  .dynamic
	index  tag                value
	[0]  NEEDED            0x564e9             libsocket.so.1
	[1]  NEEDED            0x56528             librt.so.1
	[2]  NEEDED            0x5653c             libpthread.so.1
	[3]  NEEDED            0x56555             libumem.so.1
	[4]  NEEDED            0x56562             libgcc_s.so.1
	[5]  NEEDED            0x5658a             libc.so.1
	[6]  INIT              0x1aac60
	[7]  FINI              0x1aac70
	[8]  RUNPATH           0x56630             /usr/gcc/14/lib/amd64
	[9]  RPATH             0x56630             /usr/gcc/14/lib/amd64
	[10]  HASH              0x2b930
	[11]  STRTAB            0x48130
	[12]  STRSZ             0x56846
	[13]  SYMTAB            0x398f8
	[14]  SYMENT            0x18
	[15]  SUNW_SYMTAB       0x306a0
	[16]  SUNW_SYMSZ        0x17a90
	[17]  SUNW_SORTENT      0x4
	[18]  SUNW_SYMSORT      0x9ff18
	[19]  SUNW_SYMSORTSZ    0x3b3c
	[20]  CHECKSUM          0x2c97
	[21]  VERNEED           0x9e978
	[22]  VERNEEDNUM        0x6
	[23]  RELACOUNT         0x8ad
	[24]  FINI_ARRAY        0x1e87e0
	[25]  FINI_ARRAYSZ      0x8
	[26]  <keyword>INIT_ARRAY</keyword>        0x1e87e8
	[27]  <keyword>INIT_ARRAYSZ</keyword>      0x8
	[28]  PLTRELSZ          0x3cc0
	[29]  PLTREL            0x7
	[30]  JMPREL            0xb1c00
	[31]  RELA              0xa3a58
	[32]  RELASZ            0x11e68
	[33]  RELAENT           0x18
	[34]  SYMINFO           0x29278
	[35]  SYMINSZ           0x26b4
	[36]  SYMINENT          0x4
	[37]  FLAGS             0                   0
	[38]  FLAGS_1           0x208000            [ DISPLACE-RELOCS-DONE EDITED ]
	[39]  SUNW_STRPAD       0x200
	[40]  SUNW_LDMACH       0x3e                EM_AMD64
	[41]  PLTGOT            0x1e7088
    [42-52]  NULL              0
	  </code>

	  <p>
	    So, what happens if I change these values to the values for the other <icode>.init_array</icode> section?
	    We can do that easily with <a href="/man/elfedit.1.html"><man-ref>elfedit(1)</man-ref></a>.
	    Note that we also set the <icode>sh_type</icode> of the "wrong" section to
	    <icode>SHT_NULL</icode>, I'm not sure if it is needed but <a href="/man/elfdump.1.html"><man-ref>elfdump(1)</man-ref></a>
	    complains if I don't do it.
	  </p>

	  <code>
    <filter>$</filter> <keyword>elfedit</keyword> priv/native/rustler_serde_test.so
    <filter>&gt;</filter> <keyword>dyn:value</keyword> DT_INIT_ARRAY 0x1e87f0
    <filter>&gt;</filter> <keyword>dyn:value</keyword> DT_INIT_ARRAYSZ 0x50
    <filter>&gt;</filter> <keyword>shdr:sh_type</keyword> -shndx 693 SHT_NULL
    <filter>&gt;</filter> <keyword>sys:write</keyword>
    <filter>&gt;</filter> <keyword>sys:quit</keyword>
	  </code>

	  <p>
	    Aaaand... <em>it works!</em> NIFs now are properly loaded.
	  </p>

	  <h2>Next steps and open questions</h2>

	  <p>
	    For now this has unblocked the release of my project, I've added
	    an extra step when building to change the dynamic table values so the corrent
	    <icode>.init_array</icode> gets called. However, a question remains, why are two
	    separate sections created while in Linux there's only one section? It must
	    of course be a difference in the linkers. I haven't found a way to force the linker
	    to merge both sections, if you know let me know at
	    <strong>marce [at] dziban [dot] net</strong>. My best guess is that both sections have
	    different flags, which prevents the sections from merging. The "wrong" section has
	    <icode>sh_flags: [ SHF_WRITE SHF_ALLOC ]</icode> while the correct one has
	    <icode>sh_flags: [ SHF_WRITE SHF_ALLOC 0x100000 ]</icode>. That <icode>0x100000</icode>
	    flag is a Solaris flag that is not recognized by Illumos, from my research it corresponds
	    to <icode>SHF_SUNW_NODISCARD</icode>, which prevents the compiler and linker from
	    discarding the section even if it appears unused. I wonder what's adding that flag?
	    <a href="https://reviews.llvm.org/D107955">Is it LLVM?</a> Maybe the <icode>#[used]</icode>
	    macro from the <em>Inventory</em> crate?
	  </p>
	</div>
      </main>
    </div>
  </body>
</html>
